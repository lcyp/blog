"use strict";(self.webpackChunkmyblog=self.webpackChunkmyblog||[]).push([[8119],{6262:(i,s)=>{s.A=(i,s)=>{const t=i.__vccOpts||i;for(const[i,e]of s)t[i]=e;return t}},9105:(i,s,t)=>{t.r(s),t.d(s,{comp:()=>r,data:()=>h});var e=t(641);const n=t.p+"assets/img/image.42f81554.png",a=t.p+"assets/img/image-1.1115856d.png",l={},r=(0,t(6262).A)(l,[["render",function(i,s){return(0,e.uX)(),(0,e.CE)("div",null,s[0]||(s[0]=[(0,e.Fv)('<h1 id="代理模式" tabindex="-1"><a class="header-anchor" href="#代理模式"><span>代理模式</span></a></h1><h2 id="代理模式的概念" tabindex="-1"><a class="header-anchor" href="#代理模式的概念"><span>代理模式的概念</span></a></h2><p>代理模式的核心思想是通过代理对象（例如：媒人）来替代对真实对象（如相亲对象）的直接访问，从而在不修改原始目标对象（你自己）的前提下，提供额外的功能或扩展。</p><p>主要作用：<strong>扩展目标对象的功能</strong>。例如，在目标对象的某个方法执行前后增加自定义操作。</p><hr><h2 id="静态代理与动态代理的区别" tabindex="-1"><a class="header-anchor" href="#静态代理与动态代理的区别"><span>静态代理与动态代理的区别</span></a></h2><h3 id="静态代理" tabindex="-1"><a class="header-anchor" href="#静态代理"><span>静态代理</span></a></h3><ul><li><strong>特点</strong>：在编译阶段生成代理类，需手动为每个目标对象编写代理类。</li><li><strong>缺点</strong>： <ol><li>不灵活，目标对象的每个方法都需要单独实现增强逻辑。</li><li>如果接口新增方法，代理类和目标类都需要更新。</li><li>实际开发中使用较少。</li></ol></li><li><strong>JVM层面</strong>：编译时生成实际的 <code>.class</code> 文件。</li></ul><h3 id="动态代理" tabindex="-1"><a class="header-anchor" href="#动态代理"><span>动态代理</span></a></h3><ul><li><strong>特点</strong>：动态代理无需为每个目标对象手动编写代理类，灵活性更高。</li><li><strong>优势</strong>： <ol><li>不需要目标对象必须实现接口（若实现接口，则优先使用 JDK 动态代理）。</li><li>在运行时动态生成类的字节码并加载到 JVM 中。</li><li>更适用于复杂和动态变化的场景。</li></ol></li></ul><hr><h2 id="动态代理的两种实现方式" tabindex="-1"><a class="header-anchor" href="#动态代理的两种实现方式"><span>动态代理的两种实现方式</span></a></h2><h3 id="_1-jdk-动态代理" tabindex="-1"><a class="header-anchor" href="#_1-jdk-动态代理"><span>1. JDK 动态代理</span></a></h3><ul><li><strong>特点</strong>：基于接口的代理技术。目标对象必须实现一个或多个接口。</li><li><strong>核心组件</strong>： <ul><li><strong><code>Proxy</code> 类</strong>：用于生成代理对象。</li><li><strong><code>InvocationHandler</code> 接口</strong>：用于定义方法增强逻辑。</li></ul></li><li><strong>实现步骤</strong>： <ol><li>实现 <code>InvocationHandler</code> 接口，重写 <code>invoke</code> 方法，定义扩展功能。</li><li>使用 <code>Proxy.newProxyInstance()</code> 方法生成代理对象。</li></ol></li></ul><h4 id="示例代码" tabindex="-1"><a class="header-anchor" href="#示例代码"><span>示例代码</span></a></h4><figure><img src="'+n+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><blockquote><p>可以看到JDK动态代理在方法调用时需要通过反射机制来调用目标方法，因此性能略低于CGLIB动态代理，虽然JDK动态代理在Java8进行了性能改进，但是CGLIB动态代理调用性能还是更高。因为CGLIB动态代理不需要通过反射来进行方法调用，直接调用目标方法，还不需要类型的转换。</p></blockquote><h3 id="_2-cglib-动态代理" tabindex="-1"><a class="header-anchor" href="#_2-cglib-动态代理"><span>2. CGLIB 动态代理</span></a></h3><p>CGLIB (Code Generation Library) 是一个基于 <strong>ASM</strong> 的字节码生成库，它允许在运行时对字节码进行修改和动态生成。CGLIB 通过<strong>继承方式</strong>实现代理。许多知名的开源框架（例如 Spring 的 AOP 模块）都使用了 CGLIB：</p><ul><li>如果目标对象实现了接口，则 Spring 默认使用 <strong>JDK 动态代理</strong>。</li><li>如果目标对象未实现接口，则使用 <strong>CGLIB 动态代理</strong>。 与 JDK 动态代理不同，CGLIB 动态代理需要额外引入依赖：</li></ul><div class="language-xml line-numbers-mode" data-highlighter="shiki" data-ext="xml" data-title="xml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;cglib&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">groupId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;cglib&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">artifactId</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">version</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;2.2.2&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">version</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">dependency</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="示例代码-1" tabindex="-1"><a class="header-anchor" href="#示例代码-1"><span>示例代码</span></a></h4><figure><img src="'+a+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure>',23)]))}]]),h=JSON.parse('{"path":"/zh/posts/%E9%9D%A2%E8%AF%95%E6%B1%82%E8%81%8C/Spring%E7%9F%A5%E8%AF%86/1.html","title":"代理模式","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2022-01-01T00:00:00.000Z","category":["Spring知识"],"tag":["代理模式","设计模式"],"description":"代理模式 代理模式的概念 代理模式的核心思想是通过代理对象（例如：媒人）来替代对真实对象（如相亲对象）的直接访问，从而在不修改原始目标对象（你自己）的前提下，提供额外的功能或扩展。 主要作用：扩展目标对象的功能。例如，在目标对象的某个方法执行前后增加自定义操作。 静态代理与动态代理的区别 静态代理 特点：在编译阶段生成代理类，需手动为每个目标对象编写代...","head":[["meta",{"property":"og:url","content":"https://lcyp.github.io/blog/zh/blog/zh/posts/%E9%9D%A2%E8%AF%95%E6%B1%82%E8%81%8C/Spring%E7%9F%A5%E8%AF%86/1.html"}],["meta",{"property":"og:site_name","content":"𝖑𝖎𝖆𝖓𝖌𝖈𝖍𝖊𝖓𝖞𝖆𝖓𝖌\'𝖘 𝖇𝖑𝖔𝖌"}],["meta",{"property":"og:title","content":"代理模式"}],["meta",{"property":"og:description","content":"代理模式 代理模式的概念 代理模式的核心思想是通过代理对象（例如：媒人）来替代对真实对象（如相亲对象）的直接访问，从而在不修改原始目标对象（你自己）的前提下，提供额外的功能或扩展。 主要作用：扩展目标对象的功能。例如，在目标对象的某个方法执行前后增加自定义操作。 静态代理与动态代理的区别 静态代理 特点：在编译阶段生成代理类，需手动为每个目标对象编写代..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-23T15:45:08.000Z"}],["meta",{"property":"article:tag","content":"代理模式"}],["meta",{"property":"article:tag","content":"设计模式"}],["meta",{"property":"article:published_time","content":"2022-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-23T15:45:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"代理模式\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-23T15:45:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"梁晨阳\\",\\"url\\":\\"https://lcyp.github.io/blog/zh/\\"}]}"]]},"headers":[{"level":2,"title":"代理模式的概念","slug":"代理模式的概念","link":"#代理模式的概念","children":[]},{"level":2,"title":"静态代理与动态代理的区别","slug":"静态代理与动态代理的区别","link":"#静态代理与动态代理的区别","children":[{"level":3,"title":"静态代理","slug":"静态代理","link":"#静态代理","children":[]},{"level":3,"title":"动态代理","slug":"动态代理","link":"#动态代理","children":[]}]},{"level":2,"title":"动态代理的两种实现方式","slug":"动态代理的两种实现方式","link":"#动态代理的两种实现方式","children":[{"level":3,"title":"1. JDK 动态代理","slug":"_1-jdk-动态代理","link":"#_1-jdk-动态代理","children":[]},{"level":3,"title":"2. CGLIB 动态代理","slug":"_2-cglib-动态代理","link":"#_2-cglib-动态代理","children":[]}]}],"git":{"createdTime":1731560569000,"updatedTime":1732376708000,"contributors":[{"name":"lcy","email":"2089117474@qq.com","commits":2}]},"readingTime":{"minutes":2.41,"words":724},"filePathRelative":"zh/posts/面试求职/Spring知识/1.md","localizedDate":"2022年1月1日","excerpt":"\\n<h2>代理模式的概念</h2>\\n<p>代理模式的核心思想是通过代理对象（例如：媒人）来替代对真实对象（如相亲对象）的直接访问，从而在不修改原始目标对象（你自己）的前提下，提供额外的功能或扩展。</p>\\n<p>主要作用：<strong>扩展目标对象的功能</strong>。例如，在目标对象的某个方法执行前后增加自定义操作。</p>\\n<hr>\\n<h2>静态代理与动态代理的区别</h2>\\n<h3>静态代理</h3>\\n<ul>\\n<li><strong>特点</strong>：在编译阶段生成代理类，需手动为每个目标对象编写代理类。</li>\\n<li><strong>缺点</strong>：\\n<ol>\\n<li>不灵活，目标对象的每个方法都需要单独实现增强逻辑。</li>\\n<li>如果接口新增方法，代理类和目标类都需要更新。</li>\\n<li>实际开发中使用较少。</li>\\n</ol>\\n</li>\\n<li><strong>JVM层面</strong>：编译时生成实际的 <code>.class</code> 文件。</li>\\n</ul>","autoDesc":true}')}}]);