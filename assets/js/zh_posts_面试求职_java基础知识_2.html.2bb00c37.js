"use strict";(self.webpackChunkmyblog=self.webpackChunkmyblog||[]).push([[3137],{6262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,t]of s)a[i]=t;return a}},8162:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>l,data:()=>h});var t=a(641);const n={},l=(0,a(6262).A)(n,[["render",function(i,s){return(0,t.uX)(),(0,t.CE)("div",null,[s[0]||(s[0]=(0,t.Lk)("p",null,"面试题",-1)),(0,t.Q3)(" more "),s[1]||(s[1]=(0,t.Fv)('<h1 id="java面试题" tabindex="-1"><a class="header-anchor" href="#java面试题"><span>java面试题</span></a></h1><h2 id="copyonwritearraylist介绍" tabindex="-1"><a class="header-anchor" href="#copyonwritearraylist介绍"><span>CopyOnWriteArrayList介绍</span></a></h2><p>在写操作（<code>add</code>、<code>remove</code> 等）时，不直接对原数据进行修改，而是先将原数据复制一份，然后在新复制的数据上执行写操作，最后将原数据引用指向新数据。这样做的好处是： <strong>读操作</strong>（<code>get</code>、<code>iterator</code> 等）可以不加锁，因为读取的数据始终是不变的。</p><p>CopyOnWriteArrayList 优缺点</p><h4 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h4><ol><li><strong>线程安全</strong><br> CopyOnWriteArrayList 是线程安全的，由于写操作对原数据进行复制，因此写操作不会影响读操作，读操作可以不加锁，降低了并发冲突的概率。</li><li><strong>不会抛出 <code>ConcurrentModificationException</code> 异常</strong><br> 由于读操作遍历的是不变的数组副本，因此不会抛出 <code>ConcurrentModificationException</code> 异常。</li></ol><h4 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h4><ol><li><strong>写操作性能较低</strong><br> 每一次写操作都需要将元素复制一份，因此写操作的性能较低。</li><li><strong>内存占用增加</strong><br> 每次写操作都需要创建一个新的数组副本，因此内存占用会增加，特别是当集合中有大量数据时，内存占用较高。</li><li><strong>数据一致性问题</strong><br> 由于读操作遍历的是不变的数组副本，因此在对数组执行写操作期间，读操作可能读取到旧的数组数据，这涉及到数据一致性问题。 CopyOnWriteArrayList 使用场景</li><li><strong>读多写少</strong><ul><li>因为写操作会复制新集合，性能较低。</li></ul></li><li><strong>集合不大</strong><ul><li>因为写操作需要复制整个集合，内存占用会较高。</li></ul></li><li><strong>实时性要求不高</strong><ul><li>因为可能会读取到旧的集合数据。</li></ul></li></ol><hr><h2 id="cyclicbarrier的理解" tabindex="-1"><a class="header-anchor" href="#cyclicbarrier的理解"><span>CyclicBarrier的理解</span></a></h2><blockquote><p>一般这个会和countdownLatch比较</p></blockquote><h4 id="cyclicbarrier-的概念" tabindex="-1"><a class="header-anchor" href="#cyclicbarrier-的概念"><span>CyclicBarrier 的概念</span></a></h4><p>CyclicBarrier 是 Java 中的一种多线程协作工具，允许多个线程在一个<strong>屏障点</strong>等待，直到所有线程都到达后一起继续执行。与 CountDownLatch 的主要区别在于：</p><ol><li><p><strong>可重复使用</strong><br> CyclicBarrier 在所有线程到达屏障点后会自动重置，可以用于处理多次需要等待的任务。</p></li><li><p><strong>可执行额外动作</strong><br> CyclicBarrier 支持在所有线程到达屏障点时，执行一个可选的动作（由 <code>Runnable</code> 指定），这为复杂场景提供了灵活性。</p></li></ol><h4 id="cyclicbarrier-的主要特点" tabindex="-1"><a class="header-anchor" href="#cyclicbarrier-的主要特点"><span>CyclicBarrier 的主要特点</span></a></h4><ol><li><p><strong>重复使用</strong></p><ul><li>每当所有线程到达屏障点后，屏障会自动重置，可以在循环任务或阶段性任务中多次使用。</li></ul></li><li><p><strong>线程协调</strong></p><ul><li>可以让多个线程在屏障点同步，协调它们同时开始执行。这在分阶段任务或并发游戏中非常有用。</li></ul></li><li><p><strong>额外逻辑</strong></p><ul><li>CyclicBarrier 提供了一个可选的构造参数：<code>Runnable</code>，用于指定所有线程到达屏障点时执行的额外动作。</li></ul></li></ol><h4 id="使用注意事项" tabindex="-1"><a class="header-anchor" href="#使用注意事项"><span>使用注意事项</span></a></h4><ol><li><p><strong>指定线程数量</strong></p><ul><li>在创建 CyclicBarrier 时，必须指定参与线程的数量。</li></ul></li><li><p><strong>同步点的实现</strong></p><ul><li>所有线程到达屏障点后，屏障解除阻塞，所有线程继续执行后续操作。</li></ul></li><li><p><strong>异常处理</strong></p><ul><li>若某个线程在等待过程中被中断或超时，会导致其他线程抛出异常。</li></ul></li></ol><h4 id="适用场景对比" tabindex="-1"><a class="header-anchor" href="#适用场景对比"><span>适用场景对比</span></a></h4><table><thead><tr><th><strong>特性</strong></th><th><strong>CyclicBarrier</strong></th><th><strong>CountDownLatch</strong></th></tr></thead><tbody><tr><td><strong>是否可重用</strong></td><td>是</td><td>否</td></tr><tr><td><strong>线程数量</strong></td><td>必须在创建时指定，并固定</td><td>可由计数器的值动态控制</td></tr><tr><td><strong>额外动作</strong></td><td>支持，在屏障点可以执行指定的 <code>Runnable</code></td><td>不支持</td></tr><tr><td><strong>应用场景</strong></td><td>多阶段任务、线程协作同步</td><td>一次性同步，如等待某些初始化完成后执行</td></tr></tbody></table><hr><h2 id="countdownlatch的理解" tabindex="-1"><a class="header-anchor" href="#countdownlatch的理解"><span>CountDownLatch的理解</span></a></h2><p>CountDownLatch 是 Java 中用于多线程协作的辅助类，可以让一个或多个线程等待其他线程完成某个任务后再继续执行。</p><h4 id="工作原理" tabindex="-1"><a class="header-anchor" href="#工作原理"><span>工作原理</span></a></h4><p>CountDownLatch 通过一个<strong>计数器</strong>实现：</p><ol><li>创建时设置计数器初始值，表示需要等待的线程数量或任务数量。</li><li>每个线程完成任务后调用 <code>countDown()</code> 方法，计数器减 1。</li><li>当计数器的值减至 0 时，所有在 <code>await()</code> 方法上等待的线程将被唤醒，继续执行后续操作。</li></ol><h4 id="countdownlatch-的主要作用" tabindex="-1"><a class="header-anchor" href="#countdownlatch-的主要作用"><span>CountDownLatch 的主要作用</span></a></h4><ol><li><p><strong>主线程等待多个子线程完成任务</strong></p><ul><li>主线程调用 <code>await()</code> 方法等待，子线程完成任务后调用 <code>countDown()</code>，当所有子线程完成任务后，主线程被唤醒执行后续逻辑。</li></ul></li><li><p><strong>多个线程等待外部事件的发生</strong></p><ul><li>多个线程可以同时等待某个共同的事件，例如等待资源准备就绪或信号触发。</li></ul></li><li><p><strong>控制并发任务的同时开始</strong></p><ul><li>在某些并发场景中，需要等待所有线程都准备就绪后才能同时开始执行任务，CountDownLatch提供了一种便捷的方式来实现这一需求。</li></ul></li></ol><h4 id="countdownlatch-的特点" tabindex="-1"><a class="header-anchor" href="#countdownlatch-的特点"><span>CountDownLatch 的特点</span></a></h4><ol><li><p><strong>一次性使用</strong></p><ul><li>CountDownLatch 的计数器<strong>无法重置</strong>。一旦计数器减至 0，就无法再次使用。如果需要重复使用计数器，应使用 <strong>CyclicBarrier</strong>。</li></ul></li><li><p><strong>线程安全</strong></p><ul><li>CountDownLatch 内部通过 <strong>共享锁机制</strong> 保证线程安全。</li></ul></li><li><p><strong>实现灵活</strong></p><ul><li>可以协调单个线程与多个线程、多个线程之间的执行顺序。</li></ul></li></ol><h4 id="countdownlatch-与-cyclicbarrier-的对比" tabindex="-1"><a class="header-anchor" href="#countdownlatch-与-cyclicbarrier-的对比"><span>CountDownLatch 与 CyclicBarrier 的对比</span></a></h4><table><thead><tr><th><strong>特性</strong></th><th><strong>CountDownLatch</strong></th><th><strong>CyclicBarrier</strong></th></tr></thead><tbody><tr><td><strong>是否可重用</strong></td><td>否</td><td>是</td></tr><tr><td><strong>计数器行为</strong></td><td>单向递减，无法重置</td><td>固定线程数，到达后屏障重置</td></tr><tr><td><strong>等待目标</strong></td><td>线程等待其他线程完成</td><td>线程相互等待，直到所有线程到达屏障点</td></tr><tr><td><strong>额外动作</strong></td><td>不支持</td><td>支持，屏障点可执行指定的 <code>Runnable</code></td></tr><tr><td><strong>应用场景</strong></td><td>等待任务完成、控制执行顺序</td><td>多线程同步起点，分阶段任务</td></tr><tr><td><strong>实现机制</strong></td><td>借助共享锁，计数器递减至 0 时唤醒线程</td><td>借助条件变量，所有线程到达屏障点后同时执行</td></tr></tbody></table><h4 id="使用场景示例" tabindex="-1"><a class="header-anchor" href="#使用场景示例"><span>使用场景示例</span></a></h4><ol><li><strong>主线程等待多个子线程完成任务</strong><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">CountDownLatch</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> latch </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> CountDownLatch</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 模拟子线程任务</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">currentThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot; 正在执行任务&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sleep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">currentThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getName</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot; 任务完成&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">InterruptedException</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> e</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            e</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">printStackTrace</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            latch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">countDown</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 任务完成，计数器减 1</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    })</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;主线程等待子线程完成...&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">latch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">await</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 等待计数器归 0</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;所有子线程完成任务，主线程继续执行&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><hr>',35))])}]]),h=JSON.parse('{"path":"/zh/posts/%E9%9D%A2%E8%AF%95%E6%B1%82%E8%81%8C/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.html","title":"java面试题","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2022-01-01T00:00:00.000Z","category":["java面试题"],"tag":["红","大","圆"],"description":"面试题","head":[["meta",{"property":"og:url","content":"https://lcyp.github.io/blog/zh/blog/zh/posts/%E9%9D%A2%E8%AF%95%E6%B1%82%E8%81%8C/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.html"}],["meta",{"property":"og:site_name","content":"𝖑𝖎𝖆𝖓𝖌𝖈𝖍𝖊𝖓𝖞𝖆𝖓𝖌\'𝖘 𝖇𝖑𝖔𝖌"}],["meta",{"property":"og:title","content":"java面试题"}],["meta",{"property":"og:description","content":"面试题"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-02T06:55:48.000Z"}],["meta",{"property":"article:tag","content":"红"}],["meta",{"property":"article:tag","content":"大"}],["meta",{"property":"article:tag","content":"圆"}],["meta",{"property":"article:published_time","content":"2022-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-02T06:55:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"java面试题\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-01-02T06:55:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"梁晨阳\\",\\"url\\":\\"https://lcyp.github.io/blog/zh/\\"}]}"]]},"headers":[{"level":2,"title":"CopyOnWriteArrayList介绍","slug":"copyonwritearraylist介绍","link":"#copyonwritearraylist介绍","children":[]},{"level":2,"title":"CyclicBarrier的理解","slug":"cyclicbarrier的理解","link":"#cyclicbarrier的理解","children":[]},{"level":2,"title":"CountDownLatch的理解","slug":"countdownlatch的理解","link":"#countdownlatch的理解","children":[]}],"git":{"createdTime":1731560569000,"updatedTime":1735800948000,"contributors":[{"name":"lcy","email":"2089117474@qq.com","commits":2},{"name":"lcyp","email":"2089117474@qq.com","commits":1}]},"readingTime":{"minutes":5.37,"words":1611},"filePathRelative":"zh/posts/面试求职/java基础知识/2.md","localizedDate":"2022年1月1日","excerpt":"<p>面试题</p>\\n","autoDesc":true}')}}]);