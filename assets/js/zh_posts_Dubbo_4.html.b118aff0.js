"use strict";(self.webpackChunkmyblog=self.webpackChunkmyblog||[]).push([[4622],{6262:(t,a)=>{a.A=(t,a)=>{const e=t.__vccOpts||t;for(const[t,i]of a)e[t]=i;return e}},6090:(t,a,e)=>{e.r(a),e.d(a,{comp:()=>w,data:()=>T});var i=e(641);const l=e.p+"assets/img/image-10.1662eacc.png",s=e.p+"assets/img/image-11.0afeaf10.png",r=e.p+"assets/img/image-12.526e9ff9.png",n=e.p+"assets/img/image-13.8f1ed938.png",o=e.p+"assets/img/image-14.f576a183.png",g=e.p+"assets/img/image-15.b31c0b73.png",p=e.p+"assets/img/image-16.819db24c.png",b=e.p+"assets/img/image-17.ae61a54d.png",c=e.p+"assets/img/image-18.f7cbf6ed.png",d=e.p+"assets/img/image-19.153f61c2.png",m=e.p+"assets/img/image-20.92ec5ab3.png",h=e.p+"assets/img/image-21.c90be6fd.png",u=e.p+"assets/img/image-22.e3773d15.png",y=e.p+"assets/img/image-23.fc29b7d7.png",f=e.p+"assets/img/image-24.675ae1e6.png",x=e.p+"assets/img/image-25.749553c0.png",z=e.p+"assets/img/image-26.eb4e88c3.png",k=e.p+"assets/img/image-27.a5e9ff3d.png",D=e.p+"assets/img/image-28.bdf71e54.png",v=e.p+"assets/img/image-29.0fb2e098.png",C={},w=(0,e(6262).A)(C,[["render",function(t,a){return(0,i.uX)(),(0,i.CE)("div",null,[a[0]||(a[0]=(0,i.Lk)("p",null,"Dubbo的高级特性",-1)),(0,i.Q3)(" more "),a[1]||(a[1]=(0,i.Fv)('<h2 id="高级特性一-序列化" tabindex="-1"><a class="header-anchor" href="#高级特性一-序列化"><span>高级特性一-序列化：</span></a></h2><p>dubbo内部已经将序列化和反序列化的过程内部封装了<br> 我们只需要定义pojo类时实现Serializable接口即可<br> 一般会定义一个公共的pojo模块，让生产者和消费者都依赖该模块。<br> 修改Dubbo的案例如下：<br> 1，创建pojo模块，实体类需要实现Serizlizable接口：<br><img src="'+l+'" alt="alt text" loading="lazy"> 2，公共接口模块定义一个接口findUserById(int id)<br><img src="'+s+'" alt="alt text" loading="lazy"> 3,服务提供者实现这个接口：<br><img src="'+r+'" alt="alt text" loading="lazy"> 4，服务消费者消费这个接口：<br><img src="'+n+'" alt="alt text" loading="lazy"> 发起请求进行测试：<br><img src="'+o+'" alt="alt text" loading="lazy"> 可以看到返回了json类型的数据。</p><h2 id="高级特性二-地址缓存" tabindex="-1"><a class="header-anchor" href="#高级特性二-地址缓存"><span>高级特性二-地址缓存：</span></a></h2><p>注册中心挂了，服务是否可以正常访问？<br> 答案是可以的，因为Dubbo服务消费者在第一次调用时，会将服务提供方地址缓存到本地，以后在调用则不会访问注册中心。<br> 当服务提供者地址发生变化时，注册中心会通知服务消费者。</p><h2 id="高级特性三-超时-重试" tabindex="-1"><a class="header-anchor" href="#高级特性三-超时-重试"><span>高级特性三-超时&amp;重试：</span></a></h2><figure><img src="'+g+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><ol><li>服务消费者在调用服务提供者的时候发生了阻塞、等待的情形，这个时候，服务消费者会一直等待下去。</li><li>在某个峰值时刻，大量的请求都在同时请求服务消费者，会造成线程的大量堆积，势必会造成雪崩。</li><li>dubbo利用超时机制来解决这个问题，设置一个超时时间，在这个时间段内，无法完成服务访问，则自动断开连接。</li><li>使用timeout属性配置超时时间，默认值1000，单位毫秒。</li><li>在服务提供者和服务消费者都可以设置超时时间，最好设置在服务提供者方。</li><li>重试可以在服务超时之后进行重试连接，重试次数默认2次。 <img src="'+p+'" alt="alt text" loading="lazy"><br><img src="'+b+'" alt="alt text" loading="lazy"></li></ol><h2 id="高级特性四-多版本" tabindex="-1"><a class="header-anchor" href="#高级特性四-多版本"><span>高级特性四-多版本：</span></a></h2><p><img src="'+c+'" alt="alt text" loading="lazy"> 在服务提供方可以设置多个版本：<br><img src="'+d+'" alt="alt text" loading="lazy"><img src="'+m+'" alt="alt text" loading="lazy"> 在服务调用方可以选择使用哪个版本：<br><img src="'+h+'" alt="alt text" loading="lazy"></p><h2 id="高级特性五-负载均衡" tabindex="-1"><a class="header-anchor" href="#高级特性五-负载均衡"><span>高级特性五-负载均衡：</span></a></h2><p>Dubbo提供了4中不同的负载均衡的策略：<br> ● Random：按权重随机，默认设置。按权重设置随机概率。<br> ● RoundRobin：按权重轮询。就是轮流访问，访问到的就减掉一定的权重。<br> ● LeastActive：最少活跃调用数，相同活跃数的随机。找最快的服务。<br> ● ConsistentHash：一致性Hash,相同参数的请求总是发到同一提供者。<br> 一致性Hash例子：<br><img src="'+u+'" alt="alt text" width="400" loading="lazy"><br> 可以在服务调用者配置负载均衡：<br><img src="'+y+'" alt="alt text" width="700" loading="lazy"><br> 修改几个端口，启动多个相同的服务提供者，使之成为一个集群：<br><img src="'+f+'" alt="alt text" width="700" loading="lazy"><br><img src="'+x+'" alt="alt text" width="700" loading="lazy"><br> 在dubbo admin可以看到：<br><img src="'+z+'" alt="alt text" width="700" loading="lazy"></p><h2 id="高级特性六-集群容错" tabindex="-1"><a class="header-anchor" href="#高级特性六-集群容错"><span>高级特性六-集群容错：</span></a></h2><p>可以在服务消费者设置集群容错的策略：<br><img src="'+k+'" alt="alt text" width="700" loading="lazy"><br><img src="'+D+'" alt="alt text" width="300" loading="lazy"><br> 集群容错模式：<br> ● Failover Cluster:失败重试。默认值。当出现失败，重试其它服务器，默认重试2次，使用retries配置。一般用于读操作。<br> ● Failfast Cluster:快速失败，只发起一次调用，失败立即报错。通常用于写操作。<br> ● Failsafe Cluster:失败安全，出现异常时，直接忽略。返回一个空结果。<br> ● FailbackCluster:失败自动恢复，后台记录失败请求，定时重发。<br> ● Forking Cluster:并行调用多个服务器，只要一个成功即返回。<br> ● Broadcast Cluster:广播调用所有提供者，逐个调用，任意一台报错则报错。</p><h2 id="高级特性七-服务降级" tabindex="-1"><a class="header-anchor" href="#高级特性七-服务降级"><span>高级特性七-服务降级：</span></a></h2><p>● mock=force:return null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。<br> ● 还可以改为 mock=fail:return null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</p><p>可以在服务消费者配置服务降级的选择：<br><img src="'+v+'" alt="alt text" loading="lazy"></p>',16))])}]]),T=JSON.parse('{"path":"/zh/posts/Dubbo/4.html","title":"Dubbo的高级特性","lang":"zh-CN","frontmatter":{"title":"Dubbo的高级特性","icon":"pen-to-square","date":"2024-12-31T00:00:00.000Z","sticky":true,"category":["Dubbo"],"tag":["dubbo"],"star":true,"description":"Dubbo的高级特性","head":[["meta",{"property":"og:url","content":"https://lcyp.github.io/blog/zh/blog/zh/posts/Dubbo/4.html"}],["meta",{"property":"og:site_name","content":"𝖑𝖎𝖆𝖓𝖌𝖈𝖍𝖊𝖓𝖞𝖆𝖓𝖌\'𝖘 𝖇𝖑𝖔𝖌"}],["meta",{"property":"og:title","content":"Dubbo的高级特性"}],["meta",{"property":"og:description","content":"Dubbo的高级特性"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-31T09:54:39.000Z"}],["meta",{"property":"article:tag","content":"dubbo"}],["meta",{"property":"article:published_time","content":"2024-12-31T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-31T09:54:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Dubbo的高级特性\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-12-31T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-31T09:54:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"梁晨阳\\",\\"url\\":\\"https://lcyp.github.io/blog/zh/\\"}]}"]]},"headers":[{"level":2,"title":"高级特性一-序列化：","slug":"高级特性一-序列化","link":"#高级特性一-序列化","children":[]},{"level":2,"title":"高级特性二-地址缓存：","slug":"高级特性二-地址缓存","link":"#高级特性二-地址缓存","children":[]},{"level":2,"title":"高级特性三-超时&重试：","slug":"高级特性三-超时-重试","link":"#高级特性三-超时-重试","children":[]},{"level":2,"title":"高级特性四-多版本：","slug":"高级特性四-多版本","link":"#高级特性四-多版本","children":[]},{"level":2,"title":"高级特性五-负载均衡：","slug":"高级特性五-负载均衡","link":"#高级特性五-负载均衡","children":[]},{"level":2,"title":"高级特性六-集群容错：","slug":"高级特性六-集群容错","link":"#高级特性六-集群容错","children":[]},{"level":2,"title":"高级特性七-服务降级：","slug":"高级特性七-服务降级","link":"#高级特性七-服务降级","children":[]}],"git":{"createdTime":1735638879000,"updatedTime":1735638879000,"contributors":[{"name":"lcyp","email":"2089117474@qq.com","commits":1}]},"readingTime":{"minutes":3.72,"words":1117},"filePathRelative":"zh/posts/Dubbo/4.md","localizedDate":"2024年12月31日","excerpt":"<p>Dubbo的高级特性</p>\\n","autoDesc":true}')}}]);